


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > Vault</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.cryptomator.common.vaults</a>
</div>

<h1>Coverage Summary for Class: Vault (org.cryptomator.common.vaults)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Vault</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/151)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*******************************************************************************
&nbsp; * Copyright (c) 2016, 2017 Sebastian Stenzel and others.
&nbsp; * All rights reserved.
&nbsp; * This program and the accompanying materials are made available under the terms of the accompanying LICENSE file.
&nbsp; *
&nbsp; * Contributors:
&nbsp; *     Sebastian Stenzel - initial API and implementation
&nbsp; *******************************************************************************/
&nbsp;package org.cryptomator.common.vaults;
&nbsp;
&nbsp;import org.apache.commons.lang3.SystemUtils;
&nbsp;import org.cryptomator.common.Constants;
&nbsp;import org.cryptomator.common.mount.Mounter;
&nbsp;import org.cryptomator.common.settings.Settings;
&nbsp;import org.cryptomator.common.settings.VaultSettings;
&nbsp;import org.cryptomator.cryptofs.CryptoFileSystem;
&nbsp;import org.cryptomator.cryptofs.CryptoFileSystemProperties;
&nbsp;import org.cryptomator.cryptofs.CryptoFileSystemProperties.FileSystemFlags;
&nbsp;import org.cryptomator.cryptofs.CryptoFileSystemProvider;
&nbsp;import org.cryptomator.cryptofs.common.FileSystemCapabilityChecker;
&nbsp;import org.cryptomator.cryptolib.api.CryptoException;
&nbsp;import org.cryptomator.cryptolib.api.MasterkeyLoader;
&nbsp;import org.cryptomator.cryptolib.api.MasterkeyLoadingFailedException;
&nbsp;import org.cryptomator.integrations.mount.MountFailedException;
&nbsp;import org.cryptomator.integrations.mount.Mountpoint;
&nbsp;import org.cryptomator.integrations.mount.UnmountFailedException;
&nbsp;import org.cryptomator.integrations.quickaccess.QuickAccessService;
&nbsp;import org.cryptomator.integrations.quickaccess.QuickAccessServiceException;
&nbsp;import org.jetbrains.annotations.NotNull;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;import javax.inject.Inject;
&nbsp;import javax.inject.Named;
&nbsp;import javafx.beans.Observable;
&nbsp;import javafx.beans.binding.Bindings;
&nbsp;import javafx.beans.binding.BooleanBinding;
&nbsp;import javafx.beans.binding.ObjectBinding;
&nbsp;import javafx.beans.binding.StringBinding;
&nbsp;import javafx.beans.property.BooleanProperty;
&nbsp;import javafx.beans.property.ObjectProperty;
&nbsp;import javafx.beans.property.ReadOnlyStringProperty;
&nbsp;import javafx.beans.property.SimpleBooleanProperty;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.file.Path;
&nbsp;import java.nio.file.Paths;
&nbsp;import java.util.EnumSet;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.atomic.AtomicReference;
&nbsp;
&nbsp;@PerVault
&nbsp;public class Vault {
&nbsp;
<b class="nc">&nbsp;	private static final Logger LOG = LoggerFactory.getLogger(Vault.class);</b>
<b class="nc">&nbsp;	private static final Path HOME_DIR = Paths.get(SystemUtils.USER_HOME);</b>
&nbsp;	private static final int UNLIMITED_FILENAME_LENGTH = Integer.MAX_VALUE;
&nbsp;
&nbsp;	private final VaultSettings vaultSettings;
&nbsp;	private final AtomicReference&lt;CryptoFileSystem&gt; cryptoFileSystem;
&nbsp;	private final AtomicReference&lt;QuickAccessService.QuickAccessEntry&gt; quickAccessEntry;
&nbsp;	private final VaultState state;
&nbsp;	private final ObjectProperty&lt;Exception&gt; lastKnownException;
&nbsp;	private final VaultConfigCache configCache;
&nbsp;	private final VaultStats stats;
&nbsp;	private final StringBinding displayablePath;
&nbsp;	private final BooleanBinding locked;
&nbsp;	private final BooleanBinding processing;
&nbsp;	private final BooleanBinding unlocked;
&nbsp;	private final BooleanBinding missing;
&nbsp;	private final BooleanBinding needsMigration;
&nbsp;	private final BooleanBinding unknownError;
&nbsp;	private final ObjectBinding&lt;Mountpoint&gt; mountPoint;
&nbsp;	private final Mounter mounter;
&nbsp;	private final Settings settings;
&nbsp;	private final BooleanProperty showingStats;
&nbsp;
<b class="nc">&nbsp;	private final AtomicReference&lt;Mounter.MountHandle&gt; mountHandle = new AtomicReference&lt;&gt;(null);</b>
&nbsp;
&nbsp;	@Inject
&nbsp;	Vault(VaultSettings vaultSettings, //
&nbsp;		  VaultConfigCache configCache, //
&nbsp;		  AtomicReference&lt;CryptoFileSystem&gt; cryptoFileSystem, //
&nbsp;		  VaultState state, //
&nbsp;		  @Named(&quot;lastKnownException&quot;) ObjectProperty&lt;Exception&gt; lastKnownException, //
&nbsp;		  VaultStats stats, //
<b class="nc">&nbsp;		  Mounter mounter, Settings settings) {</b>
<b class="nc">&nbsp;		this.vaultSettings = vaultSettings;</b>
<b class="nc">&nbsp;		this.configCache = configCache;</b>
<b class="nc">&nbsp;		this.cryptoFileSystem = cryptoFileSystem;</b>
<b class="nc">&nbsp;		this.state = state;</b>
<b class="nc">&nbsp;		this.lastKnownException = lastKnownException;</b>
<b class="nc">&nbsp;		this.stats = stats;</b>
<b class="nc">&nbsp;		this.displayablePath = Bindings.createStringBinding(this::getDisplayablePath, vaultSettings.path);</b>
<b class="nc">&nbsp;		this.locked = Bindings.createBooleanBinding(this::isLocked, state);</b>
<b class="nc">&nbsp;		this.processing = Bindings.createBooleanBinding(this::isProcessing, state);</b>
<b class="nc">&nbsp;		this.unlocked = Bindings.createBooleanBinding(this::isUnlocked, state);</b>
<b class="nc">&nbsp;		this.missing = Bindings.createBooleanBinding(this::isMissing, state);</b>
<b class="nc">&nbsp;		this.needsMigration = Bindings.createBooleanBinding(this::isNeedsMigration, state);</b>
<b class="nc">&nbsp;		this.unknownError = Bindings.createBooleanBinding(this::isUnknownError, state);</b>
<b class="nc">&nbsp;		this.mountPoint = Bindings.createObjectBinding(this::getMountPoint, state);</b>
<b class="nc">&nbsp;		this.mounter = mounter;</b>
<b class="nc">&nbsp;		this.settings = settings;</b>
<b class="nc">&nbsp;		this.showingStats = new SimpleBooleanProperty(false);</b>
<b class="nc">&nbsp;		this.quickAccessEntry = new AtomicReference&lt;&gt;(null);</b>
&nbsp;	}
&nbsp;
&nbsp;	// ******************************************************************************
&nbsp;	// Commands
&nbsp;	// ********************************************************************************/
&nbsp;
&nbsp;	private CryptoFileSystem createCryptoFileSystem(MasterkeyLoader keyLoader) throws IOException, MasterkeyLoadingFailedException {
<b class="nc">&nbsp;		Set&lt;FileSystemFlags&gt; flags = EnumSet.noneOf(FileSystemFlags.class);</b>
<b class="nc">&nbsp;		if (vaultSettings.usesReadOnlyMode.get()) {</b>
<b class="nc">&nbsp;			flags.add(FileSystemFlags.READONLY);</b>
<b class="nc">&nbsp;		} else if (vaultSettings.maxCleartextFilenameLength.get() == -1) {</b>
<b class="nc">&nbsp;			LOG.debug(&quot;Determining cleartext filename length limitations...&quot;);</b>
<b class="nc">&nbsp;			var checker = new FileSystemCapabilityChecker();</b>
<b class="nc">&nbsp;			int shorteningThreshold = configCache.get().allegedShorteningThreshold();</b>
<b class="nc">&nbsp;			int ciphertextLimit = checker.determineSupportedCiphertextFileNameLength(getPath());</b>
<b class="nc">&nbsp;			if (ciphertextLimit &lt; shorteningThreshold) {</b>
<b class="nc">&nbsp;				int cleartextLimit = checker.determineSupportedCleartextFileNameLength(getPath());</b>
<b class="nc">&nbsp;				vaultSettings.maxCleartextFilenameLength.set(cleartextLimit);</b>
&nbsp;			} else {
<b class="nc">&nbsp;				vaultSettings.maxCleartextFilenameLength.setValue(UNLIMITED_FILENAME_LENGTH);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (vaultSettings.maxCleartextFilenameLength.get() &lt; UNLIMITED_FILENAME_LENGTH) {</b>
<b class="nc">&nbsp;			LOG.warn(&quot;Limiting cleartext filename length on this device to {}.&quot;, vaultSettings.maxCleartextFilenameLength.get());</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		CryptoFileSystemProperties fsProps = CryptoFileSystemProperties.cryptoFileSystemProperties() //</b>
<b class="nc">&nbsp;				.withKeyLoader(keyLoader) //</b>
<b class="nc">&nbsp;				.withFlags(flags) //</b>
<b class="nc">&nbsp;				.withMaxCleartextNameLength(vaultSettings.maxCleartextFilenameLength.get()) //</b>
<b class="nc">&nbsp;				.withVaultConfigFilename(Constants.VAULTCONFIG_FILENAME) //</b>
<b class="nc">&nbsp;				.build();</b>
<b class="nc">&nbsp;		return CryptoFileSystemProvider.newFileSystem(getPath(), fsProps);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void destroyCryptoFileSystem() {
<b class="nc">&nbsp;		LOG.trace(&quot;Trying to close associated CryptoFS...&quot;);</b>
<b class="nc">&nbsp;		CryptoFileSystem fs = cryptoFileSystem.getAndSet(null);</b>
<b class="nc">&nbsp;		if (fs != null) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				fs.close();</b>
<b class="nc">&nbsp;			} catch (IOException e) {</b>
<b class="nc">&nbsp;				LOG.error(&quot;Error closing file system.&quot;, e);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public synchronized void unlock(MasterkeyLoader keyLoader) throws CryptoException, IOException, MountFailedException {
<b class="nc">&nbsp;		if (cryptoFileSystem.get() != null) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;Already unlocked.&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		CryptoFileSystem fs = createCryptoFileSystem(keyLoader);</b>
<b class="nc">&nbsp;		boolean success = false;</b>
&nbsp;		try {
<b class="nc">&nbsp;			cryptoFileSystem.set(fs);</b>
<b class="nc">&nbsp;			var rootPath = fs.getRootDirectories().iterator().next();</b>
<b class="nc">&nbsp;			var mountHandle = mounter.mount(vaultSettings, rootPath);</b>
<b class="nc">&nbsp;			success = this.mountHandle.compareAndSet(null, mountHandle);</b>
<b class="nc">&nbsp;			if (settings.useQuickAccess.getValue()) {</b>
<b class="nc">&nbsp;				addToQuickAccess();</b>
&nbsp;			}
&nbsp;		} finally {
<b class="nc">&nbsp;			if (!success) {</b>
<b class="nc">&nbsp;				destroyCryptoFileSystem();</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	public synchronized void lock(boolean forced) throws UnmountFailedException, IOException {
<b class="nc">&nbsp;		var mountHandle = this.mountHandle.get();</b>
<b class="nc">&nbsp;		if (mountHandle == null) {</b>
&nbsp;			//TODO: noop or InvalidStateException?
&nbsp;			return;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (forced &amp;&amp; mountHandle.supportsUnmountForced()) {</b>
<b class="nc">&nbsp;			mountHandle.mountObj().unmountForced();</b>
&nbsp;		} else {
<b class="nc">&nbsp;			mountHandle.mountObj().unmount();</b>
&nbsp;		}
&nbsp;
&nbsp;		try {
<b class="nc">&nbsp;			mountHandle.mountObj().close();</b>
<b class="nc">&nbsp;			mountHandle.specialCleanup().run();</b>
&nbsp;		} finally {
<b class="nc">&nbsp;			removeFromQuickAccess();</b>
<b class="nc">&nbsp;			destroyCryptoFileSystem();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		this.mountHandle.set(null);</b>
<b class="nc">&nbsp;		LOG.info(&quot;Locked vault &#39;{}&#39;&quot;, getDisplayName());</b>
&nbsp;	}
&nbsp;
&nbsp;	private synchronized void addToQuickAccess() {
<b class="nc">&nbsp;		if (quickAccessEntry.get() != null) {</b>
&nbsp;			//we don&#39;t throw an exception since we don&#39;t wanna block unlocking
<b class="nc">&nbsp;			LOG.warn(&quot;Vault already added to quick access area. Will be removed on next lock operation.&quot;);</b>
&nbsp;			return;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		QuickAccessService.get() //</b>
<b class="nc">&nbsp;				.filter(s -&gt; s.getClass().getName().equals(settings.quickAccessService.getValue())) //</b>
<b class="nc">&nbsp;				.findFirst() //</b>
<b class="nc">&nbsp;				.ifPresentOrElse( //</b>
&nbsp;						this::addToQuickAccessInternal, //
<b class="nc">&nbsp;						() -&gt; LOG.warn(&quot;Unable to add Vault to quick access area: Desired implementation not available.&quot;) //</b>
&nbsp;				);
&nbsp;	}
&nbsp;
&nbsp;	private void addToQuickAccessInternal(@NotNull QuickAccessService s) {
<b class="nc">&nbsp;		if (getMountPoint() instanceof Mountpoint.WithPath mp) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				var entry = s.add(mp.path(), getDisplayName());</b>
<b class="nc">&nbsp;				quickAccessEntry.set(entry);</b>
<b class="nc">&nbsp;			} catch (QuickAccessServiceException e) {</b>
<b class="nc">&nbsp;				LOG.error(&quot;Adding vault to quick access area failed&quot;, e);</b>
&nbsp;			}
&nbsp;		} else {
<b class="nc">&nbsp;			LOG.warn(&quot;Unable to add vault to quick access area: Vault is not mounted to local system path.&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private synchronized void removeFromQuickAccess() {
<b class="nc">&nbsp;		if (quickAccessEntry.get() == null) {</b>
<b class="nc">&nbsp;			LOG.debug(&quot;Removing vault from quick access area: Entry not found, nothing to do.&quot;);</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		removeFromQuickAccessInternal();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void removeFromQuickAccessInternal() {
&nbsp;		try {
<b class="nc">&nbsp;			quickAccessEntry.get().remove();</b>
<b class="nc">&nbsp;			quickAccessEntry.set(null);</b>
<b class="nc">&nbsp;		} catch (QuickAccessServiceException e) {</b>
<b class="nc">&nbsp;			LOG.error(&quot;Removing vault from quick access area failed&quot;, e);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	// ******************************************************************************
&nbsp;	// Observable Properties
&nbsp;	// *******************************************************************************
&nbsp;
&nbsp;	public VaultState stateProperty() {
<b class="nc">&nbsp;		return state;</b>
&nbsp;	}
&nbsp;
&nbsp;	public VaultState.Value getState() {
<b class="nc">&nbsp;		return state.getValue();</b>
&nbsp;	}
&nbsp;
&nbsp;	public ObjectProperty&lt;Exception&gt; lastKnownExceptionProperty() {
<b class="nc">&nbsp;		return lastKnownException;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Exception getLastKnownException() {
<b class="nc">&nbsp;		return lastKnownException.get();</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setLastKnownException(Exception e) {
<b class="nc">&nbsp;		lastKnownException.setValue(e);</b>
&nbsp;	}
&nbsp;
&nbsp;	public BooleanBinding lockedProperty() {
<b class="nc">&nbsp;		return locked;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isLocked() {
<b class="nc">&nbsp;		return state.get() == VaultState.Value.LOCKED;</b>
&nbsp;	}
&nbsp;
&nbsp;	public BooleanBinding processingProperty() {
<b class="nc">&nbsp;		return processing;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isProcessing() {
<b class="nc">&nbsp;		return state.get() == VaultState.Value.PROCESSING;</b>
&nbsp;	}
&nbsp;
&nbsp;	public BooleanBinding unlockedProperty() {
<b class="nc">&nbsp;		return unlocked;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isUnlocked() {
<b class="nc">&nbsp;		return state.get() == VaultState.Value.UNLOCKED;</b>
&nbsp;	}
&nbsp;
&nbsp;	public BooleanBinding missingProperty() {
<b class="nc">&nbsp;		return missing;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isMissing() {
<b class="nc">&nbsp;		return state.get() == VaultState.Value.MISSING;</b>
&nbsp;	}
&nbsp;
&nbsp;	public BooleanBinding needsMigrationProperty() {
<b class="nc">&nbsp;		return needsMigration;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isNeedsMigration() {
<b class="nc">&nbsp;		return state.get() == VaultState.Value.NEEDS_MIGRATION;</b>
&nbsp;	}
&nbsp;
&nbsp;	public BooleanBinding unknownErrorProperty() {
<b class="nc">&nbsp;		return unknownError;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isUnknownError() {
<b class="nc">&nbsp;		return state.get() == VaultState.Value.ERROR;</b>
&nbsp;	}
&nbsp;
&nbsp;	public ReadOnlyStringProperty displayNameProperty() {
<b class="nc">&nbsp;		return vaultSettings.displayName;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getDisplayName() {
<b class="nc">&nbsp;		return vaultSettings.displayName.get();</b>
&nbsp;	}
&nbsp;
&nbsp;	public ObjectBinding&lt;Mountpoint&gt; mountPointProperty() {
<b class="nc">&nbsp;		return mountPoint;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Mountpoint getMountPoint() {
<b class="nc">&nbsp;		var handle = mountHandle.get();</b>
<b class="nc">&nbsp;		return handle == null ? null : handle.mountObj().getMountpoint();</b>
&nbsp;	}
&nbsp;
&nbsp;	public StringBinding displayablePathProperty() {
<b class="nc">&nbsp;		return displayablePath;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getDisplayablePath() {
<b class="nc">&nbsp;		Path p = vaultSettings.path.get();</b>
<b class="nc">&nbsp;		if (p.startsWith(HOME_DIR)) {</b>
<b class="nc">&nbsp;			Path relativePath = HOME_DIR.relativize(p);</b>
<b class="nc">&nbsp;			String homePrefix = SystemUtils.IS_OS_WINDOWS ? &quot;~\\&quot; : &quot;~/&quot;;</b>
<b class="nc">&nbsp;			return homePrefix + relativePath.toString();</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return p.toString();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public BooleanProperty showingStatsProperty() {
<b class="nc">&nbsp;		return showingStats;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isShowingStats() {
<b class="nc">&nbsp;		return mountHandle.get() != null;</b>
&nbsp;	}
&nbsp;
&nbsp;
&nbsp;	// ******************************************************************************
&nbsp;	// Getter/Setter
&nbsp;	// *******************************************************************************/
&nbsp;
&nbsp;	public VaultStats getStats() {
<b class="nc">&nbsp;		return stats;</b>
&nbsp;	}
&nbsp;
&nbsp;
&nbsp;	public Observable[] observables() {
<b class="nc">&nbsp;		return new Observable[]{state};</b>
&nbsp;	}
&nbsp;
&nbsp;	public VaultSettings getVaultSettings() {
<b class="nc">&nbsp;		return vaultSettings;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Path getPath() {
<b class="nc">&nbsp;		return vaultSettings.path.get();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets from the cleartext path its ciphertext counterpart.
&nbsp;	 *
&nbsp;	 * @return Local os path to the ciphertext resource
&nbsp;	 * @throws IOException if an I/O error occurs
&nbsp;	 * @throws IllegalStateException if the vault is not unlocked
&nbsp;	 */
&nbsp;	public Path getCiphertextPath(Path cleartextPath) throws IOException {
<b class="nc">&nbsp;		if (!state.getValue().equals(VaultState.Value.UNLOCKED)) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;Vault is not unlocked&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		var fs = cryptoFileSystem.get();</b>
<b class="nc">&nbsp;		var osPathSeparator = cleartextPath.getFileSystem().getSeparator();</b>
<b class="nc">&nbsp;		var cryptoFsPathSeparator = fs.getSeparator();</b>
&nbsp;
<b class="nc">&nbsp;		if (getMountPoint() instanceof Mountpoint.WithPath mp) {</b>
<b class="nc">&nbsp;			var absoluteCryptoFsPath = cryptoFsPathSeparator + mp.path().relativize(cleartextPath).toString();</b>
<b class="nc">&nbsp;			if (!cryptoFsPathSeparator.equals(osPathSeparator)) {</b>
<b class="nc">&nbsp;				absoluteCryptoFsPath = absoluteCryptoFsPath.replace(osPathSeparator, cryptoFsPathSeparator);</b>
&nbsp;			}
<b class="nc">&nbsp;			var cryptoPath = fs.getPath(absoluteCryptoFsPath);</b>
<b class="nc">&nbsp;			return fs.getCiphertextPath(cryptoPath);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw new UnsupportedOperationException(&quot;URI mount points not supported.&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public VaultConfigCache getVaultConfigCache() {
<b class="nc">&nbsp;		return configCache;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getId() {
<b class="nc">&nbsp;		return vaultSettings.id;</b>
&nbsp;	}
&nbsp;
&nbsp;	// ******************************************************************************
&nbsp;	// Hashcode / Equals
&nbsp;	// *******************************************************************************/
&nbsp;
&nbsp;	@Override
&nbsp;	public int hashCode() {
<b class="nc">&nbsp;		return Objects.hash(vaultSettings);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean equals(Object obj) {
<b class="nc">&nbsp;		if (obj instanceof Vault other &amp;&amp; obj.getClass().equals(this.getClass())) {</b>
<b class="nc">&nbsp;			return Objects.equals(this.vaultSettings, other.vaultSettings);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public boolean supportsForcedUnmount() {
<b class="nc">&nbsp;		var mh = mountHandle.get();</b>
<b class="nc">&nbsp;		if (mh == null) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;Vault is not mounted&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		return mountHandle.get().supportsUnmountForced();</b>
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-10-10 15:12</div>
</div>
</body>
</html>
